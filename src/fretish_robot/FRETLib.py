# SPDX-FileCopyrightText: Copyright 2023â€“2024 Carl Zeiss Meditec AG
# SPDX-License-Identifier: Apache-2.0

import re

from robot.api.deco import keyword
from robot.libraries.BuiltIn import BuiltIn

VAREXPR_RE = re.compile(r"\$([\w_]+)")


class FRETLib:
    """Library implementing keywords to execute FRETish like syntax keywords.

    This library provides keyword implementations for keywords that are similar
    to FRET syntax and used by the fret_to_robot tool. Therefore, one needs to
    include this library to execute Robot Framework files generated by it.

    Please note that it only provides the FRET keyword implementation, not the
    behaviour for keywords regarding the SuT.
    """

    def __init__(self) -> None:
        self.built_in = BuiltIn()

    def upon(self, event_name):
        """Runs the `event_name` keyword. Like `Run Keyword` but for FRET read"""
        self.built_in.run_keyword(event_name)

    def within(self, timeframe, keyword, *keyword_args):
        """Check that `keyword` called with `keyword_args` holds true
          during a timeframe. `keyword` must a `satisfy`.

        This is done by using the 'wait_until_keyword_succeeds" keyword with a
        sleep of 0, making it executing 'keyword' during the timeframe and wait until
        it succeeds.

        Note: Right now, only expressions of 'within     xxx (milli)seconds' are supported,
        other forms of within will be implemented soon.
        """
        self.built_in.wait_until_keyword_succeeds(timeframe, 0, keyword, *keyword_args)

    def after(self, timeframe, keyword, *keyword_args):
        """After a time of `timeframe`, execute and check success of `keyword`.
        Hereby, `keyword` must be a `satisfy`.

        This is done by sleeping the given amount of time and call the argument afterwards.
        """
        self.built_in.sleep(timeframe)
        self.built_in.run_keyword(keyword, *keyword_args)

    def immediately(self, keyword, *keyword_args):
        """Immediately runs the `keyword`. Like `Run Keyword` but for FRET read"""
        self.built_in.run_keyword(keyword, *keyword_args)

    def at_the_next_timepoint(self, keyword, *keyword_args):
        """runs the `keyword` and checks as soon as possible if holds.
        Like `Run Keyword` but for FRET read"""
        self.built_in.run_keyword(keyword, *keyword_args)

    def satisfy(self, satisfiable: str):
        """Checks if `satisfiable` is satisified right now.

        Hereby, the expression **must** be the 'when-then' keyword, or a evaluatable python expression.

        Variables are substituted for the keyword with values once so all occurances have the
        same value.
        """

        expression_vars = set(VAREXPR_RE.findall(satisfiable))

        for var in expression_vars:
            res = self.built_in.run_keyword(var)
            self.built_in.set_local_variable(f"${var}", res)

        if satisfiable.startswith("when"):
            self.built_in.run_keyword(satisfiable)
        else:
            self.built_in.should_be_true(satisfiable)

    @keyword("when ${pre_cond} then ${check}")
    def when_then_construct(self, pre_cond, check):
        """Check if `pre_cond => check` is true.

        If pre_cond is false, then the whole expression is true.
        If pre_cond is true, check must also evaluates to true.
        Otherwise, the keyword throws / is false.
        """

        if self.built_in.evaluate(pre_cond):
            self.built_in.should_be_true(check)
